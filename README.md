# ЛР Linux

Для выполнения ЛР использовался следующий Dockerfile:
```dockerfile
FROM archlinux:base-20220424.0.54084

RUN pacman -Sy --noconfirm \
  sudo \
  glibc \
  tree

# Создадим непривелигированного пользователя `nonroot`,
# Это нужно, чтобы наглядно показать, как мы сможем входить через пользователя,
# т.к. в `/etc/pam.d/su` и `/etc/pam.d/su-l`, в том числе, прописано:
#   auth    sufficient    pam_rootok.so
# Это строка означает, что будут пропускаться все дальнейшие проверки,
# если `su` или `su --login` были запущены из-под суперпользователя.
RUN useradd --create-home nonroot

# Добавим опцию `nullok` для модуля PAM pam_unix.so для `su` и `su --login`,
# чтобы мы могли проверять, каким образом сможет входить пользователь без пароля.
RUN sed -i '/^auth.*pam_unix.so$/ s/$/ nullok/' /etc/pam.d/su /etc/pam.d/su-l
```

Теперь, соберем образ и запустим на основе него контейнер:
```sh
$ docker build -t hse_facl .
$ docker run --rm -it hse_facl
```
Все последующие команды выполняются внутри запущенного контейнера.

## 1. Создание пользователей. Задание паролей. Сброс пароля пользователя.

### a. Создать две учетные записи пользователей: `user1`, `user2`.
Создавать пользователей будем с помощью утилиты `useradd` с флагом `--create-home`
```sh
$ useradd --create-home user1
$ useradd --create-home user2
```
### b. Задать пользователям одинаковые пароли.
Зададим одинаковый пароль `qwerty` для пользователей `user1` и `user2`.
В данном примере для наглядности я пишу пароль два раза (для подтверждения)
в стандартный поток ввода утилиты `passwd` с помощью утилиты `printf`.
Это небезопасно, т.к., например, данная строка, содержащая пароль,
останется в файле истории вашей `${SHELL}`, а также на время существования процесса
`printf` (если это не shell-builtin) может быть получена через чтение
`/proc/<PID of printf>/cmdline`.
Однако, в данном случае, я это использую для наглядности, т.к. это учебный пример.
В реальной жизни, не рекомендуется передавать пароли в агрументах командной строки.
```sh
$ printf '%s\n%s\n' 'qwerty' 'qwerty' | passwd user1
New password: Retype new password: passwd: password updated successfully
$ printf '%s\n%s\n' 'qwerty' 'qwerty' | passwd user2
New password: Retype new password: passwd: password updated successfully
```

### c. Проанализировать файл `/etc/shadow` и `/etc/passwd`. Сделать соответствующие выводы.

```sh
$ cat /etc/shadow
root:*:14871::::::
bin:!*:19106::::::
daemon:!*:19106::::::
mail:!*:19106::::::
ftp:!*:19106::::::
http:!*:19106::::::
nobody:!*:19106::::::
dbus:!*:19106::::::
systemd-coredump:!*:19106::::::
systemd-network:!*:19106::::::
systemd-oom:!*:19106::::::
systemd-journal-remote:!*:19106::::::
systemd-resolve:!*:19106::::::
systemd-timesync:!*:19106::::::
tss:!*:19106::::::
uuidd:!*:19106::::::
nonroot:!:19121:0:99999:7:::
user1:$6$xYT1i8jqtbD02sbp$DCX/yMjf/dsBInjv257eGssUKYdWssCza8X/MZjOBd2h0UJUsWdaMzo3ivw6a1623h1IexT.0Xf0ToeuHyuOD1:19121:0:99999:7:::
user2:$6$KseaobCAXMiP/ZU7$jim1heThljwPMO5T5No8vr6eDKLJeUDpNK3yGrMKA7bjhQ7wcOZWRgx94bi1PDhic7H7XcxLlLzUEV1pvdHSi.:19121:0:99999:7:::
```

В файле `/etc/shadow` добавилось две новых строки для соответствующих пользователей.
Хоть и пароли для пользователей были одинаковые, но их сверки не совпадают, т.к. использовалась
разная соль.
Также, мы видим, что для обоих пользователей пароль был сменен на 19121-й день с 01.01.1970,
что пароль для них может быть изменен всегда, но нет ограничений по срокам.

```sh
$ cat /etc/passwd
root:x:0:0::/root:/bin/bash
bin:x:1:1::/:/usr/bin/nologin
daemon:x:2:2::/:/usr/bin/nologin
mail:x:8:12::/var/spool/mail:/usr/bin/nologin
ftp:x:14:11::/srv/ftp:/usr/bin/nologin
http:x:33:33::/srv/http:/usr/bin/nologin
nobody:x:65534:65534:Nobody:/:/usr/bin/nologin
dbus:x:81:81:System Message Bus:/:/usr/bin/nologin
systemd-coredump:x:981:981:systemd Core Dumper:/:/usr/bin/nologin
systemd-network:x:980:980:systemd Network Management:/:/usr/bin/nologin
systemd-oom:x:979:979:systemd Userspace OOM Killer:/:/usr/bin/nologin
systemd-journal-remote:x:978:978:systemd Journal Remote:/:/usr/bin/nologin
systemd-resolve:x:977:977:systemd Resolver:/:/usr/bin/nologin
systemd-timesync:x:976:976:systemd Time Synchronization:/:/usr/bin/nologin
tss:x:975:975:tss user for tpm2:/:/usr/bin/nologin
uuidd:x:68:68::/:/usr/bin/nologin
nonroot:x:1000:1000::/home/nonroot:/bin/bash
user1:x:1001:1001::/home/user1:/bin/bash
user2:x:1002:1002::/home/user2:/bin/bash
```

В файле `/etc/passwd` тоже добавилось две строки для соответствующих пользователей.
У обоих пароль задан в файле `/etc/shadow`, `user1` имеет UID `1001`, а `user2` - `1002`.
GID для обоих пользователей совпадает с их UID.
Домашние каталоги - `/home/user1` и `/home/user2`, соответственно. Login shell у обоих `/bin/bash`.

### d. Из файла /etc/shadow удалить свертку пароля пользователя user1.

Я интерпретировал задание, как "заменить свертку на пустую строку".
```sh
$ awk -i inplace 'BEGIN{FS=":"; OFS=FS} $1=="user1"{$2=""}{print}' /etc/shadow
```

### e. Проверить, каким образом user1 войдет в систему. Сделать выводы.
Проверять, как войдет пользователь, будем запуская login shell
нужного нам пользователя из-под пользователя `non-root`,
чтобы проверка `pam_rootok.so` не завершилась успехом,
и смогла вступить в силу `pam_unix.so` с выставленной нами опцией `nullok`.
```sh
$ su nonroot -c 'su --login user1'
$ id
uid=1001(user1) gid=1001(user1) groups=1001(user1)
$ pwd
/home/user1
$ exit
```
Чтобы войти через пользователя `user1` пароль не потребовался.  
Заметим, что это произошло, т.к. ранее, при создании Docker-образа,
мы добавили опцию `nullok` для модуля аутентификации `pam_unix.so`
для `su` и `su --login`, которая позволяет входить через пользователя с пустым паролем.
Если бы мы этого не сделали, то `pam_unix.so` для `su` не позволил бы нам войти в пользователя,
даже если у него пустая свертка пароля. По умолчанию, эта опция отключена.
Здесь, я использовал это в демонстационных целях.

### f. В файле /etc/shadow заменить свертку пароля для пользователя user1 сверткой пароля user2.
```sh
$ USER2_ENC_PASS="$(grep '^user2:' /etc/shadow | cut -d':' -f2)"
$ awk -v USER2_ENC_PASS="${USER2_ENC_PASS}" -i inplace 'BEGIN{FS=":"; OFS=FS} $1=="user1"{$2=USER2_ENC_PASS} {print}' /etc/shadow
```

### g. Проверить, каким образом user1 войдет в систему. Сделать выводы.
Аналогично шагу `e` войдем через пользователя `user1`. В качестве пароля введем `qwerty`.
```sh
$ su nonroot -c 'su --login user1'
Password: 
$ id
uid=1001(user1) gid=1001(user1) groups=1001(user1)
$ exit
```
Вход, как и ожидалось, был выполнен успешно. Т.к. мы тоже использовали сверку пароля `qwerty`,
просто с другой солью.

## 2. Создание пользователей вручную.

### a. Вручную (без использования команды useradd или adduser) добавить пользователя user3.
Для начала, посмотрим, в какой директории `useradd` создает домашние директории,
а также, какую оболочку использует по умолчанию, и откуда копирует файлы в домашнюю директорию.
```sh
$ cat /etc/default/useradd
GROUP=users
HOME=/home
INACTIVE=-1
EXPIRE=
SHELL=/bin/bash
SKEL=/etc/skel
CREATE_MAIL_SPOOL=no
```

Как мы видим, файлы в домашнюю директорию копируются из `/etc/skel`.
Созданим группу и пользователя `user3`, его домашнюю директорию,
установим на нее права, позволяющие только `user3` читать, писать и искать в ней.
А также, скопируем файлы из `/etc/skel` и изменим их владельца и группу.

```sh
$ printf 'user3:x:1003:\n' >> /etc/group
$ printf 'user3:x:1003:1003::/home/user3:/bin/bash\n' >> /etc/passwd
$ mkdir -p /home/user3
$ chmod 0700 /home/user3
$ cp -R /etc/skel/. /home/user3
$ chown -R user3:user3 /home/user3
```

### b-c-d.
> b. Пароль пользователя задать вручную (без использования команды passwd).
> c. Задать ограничения на пароль вручную, время действия
>    пароля 3 дня (без использования команды passwd).
> d. Задать ограничения на пароль вручную, предупреждать о
>    смене пароля за 5 дней (без использования команды passwd),
>    убедиться в наличии предупреждений.

Для генерации светки пароля воспользуемся утилитой `openssl`.
Опция `-6` означает `SHA-256`.
```sh
$ printf 'user3:%s:%d:0:3:5:::\n' "$(openssl passwd -6)" "$(($(date '+%s') / 60 / 60 / 24))"  \
  | tee -a /etc/shadow
Password: 
Verifying - Password: 
user3:$6$lDx9gGC5rj6SOv5W$gyoHcRifRv8G3vTiEulPpTEfPtEOsSqrCyJDjS8/NCzT8Y/i.C.LK9/ZKtIY5TT1k31WpSSPtbpysOcTpe77z/:19121:0:3:5:::
```

Убедимся в наличии предупреждения:
```sh
$ su nonroot -c 'su --login user3'
Password: 
Warning: your password will expire in 3 days.
$ exit
```

## 3. Добавление пользователей в привилегированную группу (sudoers).

### a. Добавить пользователю user3 возможность выполнять команды от имени пользователя user1 с запросом пароля.
Хоть в `sudoers(5)` и указано, что рекомендуется вносить правки в `/etc/sudoers`
с помощью `visudo`, в целях наглядности, мы будем писать в этот файл вручную,
т.к. точно уверены в том, что делаем.

```sh
$ printf 'user3 ALL=(user1) ALL\n' >> /etc/sudoers
```

### b. Убедиться в возможности выполнения команд от имени пользователя user1

Для наглядности, исполним команду `id`.

```sh
$ sudo -u user3 sudo -u user1 id
[sudo] password for user3: 
uid=1001(user1) gid=1001(user1) groups=1001(user1)
```

### c. Добавить пользователю user3 возможность выполнять команды от имени пользователя user2 без запроса пароля.

```sh
$ printf 'user3 ALL=(user2) NOPASSWD: ALL\n' >> /etc/sudoers
$ sudo -u user3 sudo -u user2 id
uid=1002(user2) gid=1002(user2) groups=1002(user2)
```

## 4. Разграничение прав пользователей.

### a. Создать двух пользователей user1 и user2.

Они уже созданы.

### b. В директории /tmp создать файл file.

```sh
$ touch /tmp/file
```

### c. Настроить его ACL таким образом, чтобы user1 имел
полный доступ к файлу, а user2 мог только читать из него.

```sh
$ setfacl -m u:user1:rwx /tmp/file
$ setfacl -m u:user2:r /tmp/file
```

### d.
> Убедиться, что права настроены правильно, для этого
> записать от имени user1 данные файл, а затем считать их от
> имени user2. Затем попробовать записать от имени user2 и
> убедиться, что это сделать невозможно.

Для записи от имени пользователя будем использовать утилиту `tee`,
т.к. перенаправление файлового дескриптора стандартного вывода
с помощью операторов `>` в bash (или любой другой оболочке) выполняется
из-под пользователя, от имени которого был запущен процесс bash.

```sh
$ printf '%s\n' 'Hello!' | sudo -u user1 tee /tmp/file
Hello!
$ sudo -u user2 cat /tmp/file
Hello!
$ printf '%s\n' 'Hi!' | sudo -u user2 tee -a /tmp/file
tee: /tmp/file: Permission denied
Hi!
```

## 5. Рекурсивная настройка прав директорий.

### a. В директории /tmp создать следующую структуру файлов:
> recursive/
> └── subdir

```sh
$ mkdir -p /tmp/recursive/subdir
$ tree /tmp/recursive/
/tmp/recursive/
└── subdir
```

### b.
> Рекурсивно установить ACL права на всю указанную выше
> структуру так, чтобы user1 мог писать в каждую
> поддиректорию.

```sh
$ setfacl -R -m u:user1:wx /tmp/recursive
```

### c. Убедится в правильности установки прав, создав следующую структуру от имени user1:
> recursive/
> ├── file
> └── subdir
>     └── file

```sh
$ sudo -u user1 touch /tmp/recursive/file /tmp/recursive/subdir/file
$ tree /tmp/recursive
/tmp/recursive
├── file
└── subdir
    └── file
```

## 6. ACL по умолчанию.

### a. В директории /tmp создать поддиректорию test.

```sh
$ mkdir -p /tmp/test
```

### b.
> Установить на эту директорию ACL по умолчанию таким
> образом, чтобы user1 мог только читать файлы,
> размещённые в нём, а user2 мог только записывать в файлы в нём.

```sh
$ setfacl -d -m u:user1:r,u:user2:w /tmp/test
```

### c.
> Убедиться, что права настроены правильно, для этого
> создать файл file в этой директории и попробовать записать
> в него данные сначала от имени user1, убедиться, что это
> невозможно, а затем от имени user2. Аналогично,
> попробовать считать данные по очереди за каждого из
> созданных пользователей.

```sh
$ touch /tmp/test/file

$ printf 'try write\n' | sudo -u user1 tee /tmp/test/file
tee: /tmp/test/file: Permission denied
try write
$ printf 'try write2\n' | sudo -u user2 tee /tmp/test/file
try write2

$ sudo -u user1 cat /tmp/test/file
try write2
$ sudo -u user2 cat /tmp/test/file
cat: /tmp/test/file: Permission denied
```

### d.
> Создать ещё один файл file2 в tmp. Установить его права в
> ACL так, чтобы user2 мог из него читать. Убедиться, что
> user2 имеет возможность читать из file2. Для этого от имени
> user2 записать в него данные, а затем вывести его
> содержимое на экран.

Предположу, в задании имелся в виду файл `/tmp/test/file2`,
т.к. ACL по умолчанию настроен для директории `/tmp/test`.
Также, т.к. по заданию пользователь user2 должен мочь читать и записывать в
`/tmp/test/file2`, то нам все равно придется установить права `rw`,
хоть и при создании файла он унаследует ACL по умолчанию,
выставленные на директорию `/tmp/test`.

```sh
$ touch /tmp/test/file2
$ setfacl -m u:user2:rw /tmp/test/file2
$ printf 'i am user2\n' | sudo -u user2 tee /tmp/test/file2
i am user2
$ sudo -u user2 cat /tmp/test/file2
i am user2
```

## 7. Эффективная маска.

### a. Создать в директории /tmp файл mask и записать в него произвольный текст.

```sh
$ printf 'arbitrary text\n' > /tmp/mask
```

### b. Модифицировать ACL: дать пользователю user1 право на чтение и запись в mask.

```sh
$ setfacl -m u:user1:rw /tmp/mask
```

### c. Установить в ACL этого файла эффективную маску так, чтобы никто не мог записывать в файл.

```sh
$ setfacl -m m:rx /tmp/mask
```

### d. Убедиться в том, что user1 не может ничего записать в mask, но может из него считать.

```sh
$ printf 'new text\n' | sudo -u user1 tee /tmp/mask
tee: /tmp/mask: Permission denied
new text
$ sudo -u user1 cat /tmp/mask
arbitrary text
```

Как мы видим, у `user1` нет прав, чтобы писать в файл, но читать из него он может.
Причем, содержимое файла осталось прежним, т.к. переписать мы его не смогли.

## 8. Копирование ACL.

### a.
> Создать в директории /tmp файлы source и dest и записать в
> них текстовую информацию. Установить этим файлам
> стандартные UNIX-права 660, чтобы user1 и user2 не имели
> доступа к файлам.

```sh
$ printf 'source data\n' > /tmp/source
$ printf 'dest data\n' > /tmp/dest
$ chmod 0660 /tmp/source /tmp/dest
```

### b. Настроить ACL правила source так, чтобы user1 мог читать из него, а правила dest так, чтобы из него мог читать user2.

```sh
$ setfacl -m u:user1:r /tmp/source
$ setfacl -m u:user2:r /tmp/dest
```

### c. Убедиться, что каждый из пользователей может читать из соответствующего файла.

```sh
$ sudo -u user1 cat /tmp/source
source data
$ sudo -u user2 cat /tmp/dest
dest data
```

### d. Скопировать ACL из файла source в файл dest.

```sh
$ getfacl /tmp/source | setfacl --set-file - /tmp/dest
```

### e. Убедиться, что из файла dest может читать только пользователь user1.

```sh
$ sudo -u user1 cat /tmp/dest
dest data
$ sudo -u user2 cat /tmp/dest
cat: /tmp/dest: Permission denied
```


## Контрольные вопросы

1. Перечислите основные команды для работы с пользователями и группами.

* `useradd`/`userdel` (или `adduser` / `deluser`) - создание/удаление пользователей
* `gropadd` / `groupdel` - создание/удаление групп
* `passwd` - смена пароля
* `id` - реальный и эффективный индентификаторы пользователя и группы
* `groups` - список групп, к которым принадлежит пользователь
* `sudo` - исполнение команд из-под имени другого пользователя

2. Почему нужны два разных файла /etc/passwd и /etc/shadow, почему нельля
   использовать один из них?

`/etc/passwd` доступен для чтения всем, а `/etc/shadow` только суперпользователю.
Данные, содержащиеся в `/etc/passwd` не содержат никакой секретной информации,
в отличие от `/etc/shadow`, в котором хоть и не содержится пароль открытым текстом,
но содержится дополнительная информация о том, когда был сменен пароль,
сколько он еще будет действителен и т.д. Эта информация может быть использована
в небезопасных целях.

3. Зачем нужны SUID и SGID и Stikybit?

SUID / SGID - это биты в правах доступа к файлу, говорящие о том, что,
если этот файл является исполняемым, то он будет исполняться с эффективным идентификатором
пользователя / группы, который является владельцем этого файла.

Sticky bit - это бит в правах доступа к файлу, говорящий о том, что,
если это директория, то перемещать и удалять файлы внутри этой директории
может только владелец этих файлов, вне зависимости от прав доступа,
установленных на саму директорию.

4. Зачем в Linux были введены списки контроля доступа?

ACL (списки контроля доступа) появились, потому что стандартные права UNIX
не так гибки, как это нужно в некотрых ситуациях. Например, чтобы разграничить
права доступа к файлу для нескольких пользователей, не принадлежащих к общим группам.

5. Какие базовые утилиты используются для управления ACL?

* `setfacl` - установить / заменить ACL (стандартные или по умолчанию) на файле (или рекурсивно)
* `getfacl` - получить ACL, установленные на файле (или рекурсивно).

6. Зачем нужны ACL по умолчанию?

ACL по умолчанию могут быть установлены только на директории. Эти списки контроля доступа
устанавливаются на все файлы, которые создаются внутри этой директории.

7. Как понять, что для файла установлен ACL?

Если в выводе `ls -l` права доступа к файлу оканчиваются на `+`, то это значит,
что для файла установлены ACL. Для того, чтобы посмотреть, какие именно ACL установлены,
можно вызвать утилиту `getfacl /path/to/file`.

8. Чем лучше воспользоваться, когда необходимо разрешить выполнение
   конкретного исполняемого файла конкретному пользователю
   ACL или прописать правило в sudoers?

ACL лучше подходят для этой цели, т.к.
* он проще, а значит, меньше возможностей его неправильной настройки
* он проще, а значит, меньше вероятности, что в нем найдутся уязвимости.
  Например, относительно недавно в sudo была найдена уязвимость CVE-2021-3156,
  которая позволяла сделать priviledge escalation любому непривилигированному пользователю.
* информация в `/etc/sudoers` может относится к исполняемому файлу только
  по заданному пути (или имени). Но может возникнуть ситуация, когда этот
  файл может быть перемещен в другое место (или переименован). Тогда пользователь потеряет
  возможность исполнять его.
* при использовании `sudo` EUID становится равен 0 (UID суперпользователя) или UID
  пользователя, указанном в аргументе `-u`, а, значит,
  все проверки прав доутспа к другим файлам, с которыми будет взаимодействовать процесс,
  будут производиться с UID того пользователя, для которого был запущен `sudo`.
